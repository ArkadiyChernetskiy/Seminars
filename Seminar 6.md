# Семинар 6


## Наследие C

### printf, scanf

Думаю, все тут писали любимое и не повторимое "Hello world". И вполне вероятно, делали это через `print` языка Python, либо `cout` языка C++. А что насчёт языка C, не помните как там было? Давайте попробуем вспомнить, как оно работало

<details>
<summary>Как оно было</summary>
    
    #include <stdio.h>

    int main()
    {
        printf ("Hello");
        return 0;
    }
  
</details>

Итак, по традиции имеем волшебную функцию, называемую `printf`, которая позволяет что-то печатать. И мы даже сумели вывести в консоль любимый `Hello`. Однако, хотя для середины прошлого века печать в консоль была вероятно достижением, сейчас этим ~~мало кого удивишь~~ можно хвастать разве что в кино. Сейчас же хочется более интерактивного поведения, поэтому попробуем вспомнить, как именно записывается печать переменных.

Скорее всего, в этот момент у кого-то уже пробежал в голове "*d или %d или что там было...*". И будет прав. Если в краце поссылаться на en.cppreference.com/w/c/io/fprintf, то наш printf с помощью % принимает в себя тип переменной и позицию в тексте, где требуется её напечатать. А затем, через запятую, просто список переменных (без &!).

```
#include <stdio.h>

int main()
{
    int a = 4;
    printf ("Hello, %d", a);
    return 0;
}
```

Из лекции по ссылкам я думаю вы уже понимаете, что произойдёт, если написать `&a`? Если ещё нет, то стоит попробовать скомпилировать вариант `printf ("Hello, %d", &a)`, испугаться, а потом всё же попытаться глянуть лекции). Спойлер, это адрес `a` в памяти

Вернёмся к cppref. Снизу можно увидеть большую таблицу с различными типами, которые можно применить здесь. Обратите внимание, целых три метки для безнаковых чисел! Пробуем!

```
#include <stdio.h>

int main()
{
    unsigned int b = 5;
    printf ("Hello, %o %x %u \n", b, b, b);
    b = 9;
    printf ("Hello, %o %x %u \n", b, b, b);
    b = 12;
    printf ("Hello, %o %x %u", b, b, b);
    return 0;
}
```

У вас тоже получился каждый вывод не таким, как предыдущий? Есть идеи, где мы сломали компилятор? Или что означают эти буквы "o" и "x"?

<details>
<summary>Спойлер</summary>
    
    o - обозначает вывод числа в восьмиричной системе.
    x - обозначает вывод в 16-ичной системе счисления, отсюда и такие ответы
</details>

А ещё там целых 4 типа и для `float`\\`double` типов, и в десятичном виде, и в виде экспоненты... в общем, целое поле для экспериментов, которое оставлю на вашей совести.

Кстати замедьте, всё на том же сайте cppref, выше в пунке параметров видим довольно интересные опциональные вещи по типу `-`, `+`, `#` или `.` . По факту они позволяют красиво форматировать вывод строки, и примеры работы можно сразу и глянуть внизу страницы. Если что, для `cout` доступны многие аналогичные возможности, требуется лишь ~~перейти по ссылке без смс...~~ глянуть в документацию, но не сегодня.

Хотя ладно, давайте заглянем на минутку https://en.cppreference.com/w/cpp/io/manip
и посмотрим, что можно натворить.
К примеру перейдём к тем же 3 типам вывода целых чисел `dex`, `hex`, `oct`. 

```
#include <iostream>

int main()
{
    unsigned int b = 12;
    std::cout << std::oct << b << '\n';
    std::cout << std::dec << b << '\n';
    std::cout << std::hex << b << '\n';
    std::cout << b << '\n';
    return 0;
}
```

Прошу кстати заметить, что параметр hex остался с предыдущего вызова, то есть манипуляторы меняют параметры вывода у всей последующей печати, не только в данном конкретном случае.

Кстати, в этот момент хотелось бы вспомнить о наболевших 
```
std::ios::sync_with_stdio(false);
std::cin.tie(0);
```

Если в краце, первая строчка обозначает отключение синхронизации буферов, используемых `stdio`(сишный) и `ios`(плюсовый). Иными словами, после этой команды вы не сможете предсказать, что будет печатать первее, printf или cout.

Вторая строчка означает отключение синхронизации cin с cout, то есть никто не гарантирует вам, что текст будет печататься перед вводом. Он это будет делать когда ему вздумается)

```
#include <iostream>
#include <cstdio>
 
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    int n;


    std::cout << "inter\n";
    //std::cout << "a\n" << std::endl;
    std::cin >> n;
    std::printf("%d\n", n);
    std::cout << "c\n";
}
```

Надеюсь вы приметили одну строчку закомментированной. И ещё больше надеюсь, что любопыство заставило вас раскоментировать её и попробовать запустить. Дада, всё теперь выведится правильно. А знаете почему? Ура! Листаем дальше). Но по секрету, в `endl` встроенна команда очистки буффера. Иными словами, при вызове `endl` перед переходом в новую строчку он печатает всё, что накопил за это время, тем самым у нас сначала появляется надпись, и лишь потом спрашивают ввод.

Так, теперь вернёмся к великому предку - C. Мы всё ещё не глянули на `scanf`. Тот самый, который позволит нам считывать данные.

```
#include <iostream>

int main()
{
    int a = 0;
    scanf ("%d", &a);
    printf ("%d", a);
}
```

Вновь заметьте, у нас `&` в сканфе. Вопрос на обдумать, зачем?

<details>
<summary>Нажмёшь сразу, не получишь пирожок за раздумья</summary>
    scanf требуется получить адрес переменной для того, чтобы обратиться именно к ней. В языке С не было передачи аргументов по ссылке. На вход он принимает int*/double* и т.д. и уже потом разыменовывает.
</details>

Обычно в scanf указывают только одно целевое значение для приёма, либо несколько через запятую, не более. Однако сам он, опять же по тайным знаниям из https://en.cppreference.com/w/c/io/fscanf , может делать чуть больше, вплоть хоть и частичного, но сопоставления ввода с ожидаемым налету. Будем пробовать? Естественно.

```
#include <iostream>

int main()
{
    int a = 0;
    int b = 0;
    scanf ("aa%2d%3d", &a, &b);
    printf ("%d %d", a, b);
}
```

Тут, как видим, в scanf напрямую написано, что он ожидает на вход буквы 'aa' и только потом числа. Попробуйте отдать ему что-то другое и проверить, что будет. А так же если число меньше или больше заданных (а задали мы без пробелов 2 цифры, а потом 3 цифры). 

Как видите, если не отдать ему 'aa', он расстраивается и не делает ничего. Более того, scanf и printf возвращают различные ошибки (в те времена не было исключений, хотя вы и так не знаете что это...) как результат функций. В разделе `Return value` на страницах, посвящённых им, можете прочиать подробнее (и желательно прочитайте, ибо надо учиться понимать cppref, иначе потом будет сложно). В любом случае, сильно много рассказывать про scanf не хочется, и мы просто перейдём дальше.

### malloc/realloc/free

Malloc

Что-то мне подсказывает, что вы знаете что это, но на всякий случай напомню. Никаких подводных камней, кроме краша системы выделения памяти операционной системы, тут нету. Да и в этом случае malloc это последнее, о чём нужно думать (если конечно это не вы попытались выделить слишком много памяти).

В общем `malloc` - команда, которая позволяет у операционной системы запросить память в куче, и возвращает он либо адресс, где эта выделнная память находится, либо nullpointer, если не получилось. Как пользоваться так же надеюсь знаете/помните/доходили слухи:

```
#include <iostream>

int main()
{
    int* a = (int*) malloc (10*sizeof(int));\\Всегда указываем в байтах, сколько требуется выделить памяти. Для 1го инта, напомню, это 4 байта
    std::cout << a[2];
    free(a);
}
```

Кстати, если у вас уже были касты, не скажите, в чём проблема?.. Ну на нет и суда нет. 

А ещё мы ожидаемо воспользовались `free`. Если что, эта функция говорит системе, что она вновь может пользоваться памятью, которую нам выделила недавно с помощью `malloc`. Внутрь передаётся ссылка на начало памяти, которую нужно освободить (что получили от malloc). Если отдадите нечто не то, скорее всего схватите `Segmentation Fault`, сильно проще говоря ошибку работы с памятью.

И это, не игнорьте люди free, это должен быть ваш самый любимый оператор, который всегда будет сопровождать вас ~~по реке Стикс~~ при выходе из программы и как лучший друг подчищать всё что вы натворили. Короче, если вы выделили где-то память, то прошу, не забудьте отдать назад в ОС, иначе другим программам будет тесно и они уронят ваш ПК. Как котики...

Хвостиком за ними идёт `realloc`. Так же функция работы с памятью, но по факту вместо стандартного запроса на выделение просит переместить или расширить (или сузить? Потестите) область памяти, где раньше хранились данные.

Зачем перемещать? Так память в компьютере лежит областями недвижимыми. И если для расширения одной памяти потребуется сдвинуть другую, то гораздо выгоднее будет именно выделить новую область, где будт памяти побольше, нежели двигать её соседние для расширения. Тем более, что двигать соседние запрещено именно потому что там адресса переменных изменятся и всё сломается у других программ.

```
#include <iostream>

int main()
{
    int* a = reinterpret_cast<int*> (malloc (10*sizeof(int)));//Выделим сначала 10 int
    std::cout << a << '\n';
    a = reinterpret_cast<int*> (realloc (a, 11*sizeof(int)));// Потом попросим ещё место для 1го int. Скорее всего, данные не будут перемещенны
    std::cout << a;
    a = reinterpret_cast<int*> (realloc (a, 1000000*sizeof(int)));// А вот тут мы уже наглеем по чёрному, и если данные не переместятся, то у вас точно ветер в компе гуляет
    std::cout << a;
    free(a);
}
```

По итогу такую память всё равно нужно освобождать. Но теперь, если мы переехали в новое место, то старую память можно и нужно(!) не трогать. Одна только проблема, если вы хранили указатель на один из объектов старой памяти, то он протухнет и будет указывать на место, которое теперь занято чем-то другим. Вкраце, такое поведение называется `Инвалидацией`, вы ещё кучу раз столкнётесь с ним.

В общем тут ничего сложного. Просто учимся строить ОС щеначие глазки и выклянчивать побольше памяти. Зачем? Спросите у Гугл хрома, он кажется что-то знает...

### C-style cast

Думаю многие заметили, по крайне мере можете сейчас глянуть, что в первом примере на malloc мы использовали (int*), а во втором уже было сложное слово reinterpret_cast<int*>. Первая мысль, что они делают преобразование памяти по разному... не верна. Всё они делают одинаково, но при этом не одинаково.

(int*) - Си стайл преобразование. То есть такое преобразование использовалось в языке C. По факту в случае C++ оно пытается применять по очереди разные возможные преобразования из набора `static`, `reinterpret`, `const`. Более подробно можно глянуть как обычно на нашем любимом (не отнекивайтесь, скоро полюбите) сайте https://en.cppreference.com/w/cpp/language/explicit_cast . Больше всего нас интересует первый пункт, так как остальное рассказывает про немного другие вещи (как вызовы конструктора или функций). Читаем прямо по порядку - сначала const_cast, если не получилось, то static_cast, потом reinterpret_cast, потом static_cast после const_cast, потом reinterpret_cast после const_cast и так стучим по очереди, пока хоть что-то не получится сделать. Тут, как видите, был сделан reinterpret_cast внутри C style cast.

Небольшое напоминание (или информация? Если ещё не изучили):
1. `Static_cast` - преобразование переменной в другую по заранее заданому правилу. Иными словами, если для разных типов явно прописано как получить из одного типа другой, то такое преобразование вызывается именно этой командой. Если такого преобразования нет, то будет ошибка компиляции. Важно, проверка на возможность происходит во время компиляции, именно поэтому и static. Почему важно? Потом поймёте, пока запомните.
2. `Reinterpret_cast` - Более болючее преобразование, так как по факту вместо внутренней переделки типа просто подходит к области памяти, где лежит переменная, срывает старый ярлычок с ~~маслом масленным~~ типом типа и вешает новый. Так, можно в лоб превратить все 4 байта, в которых хранится int в четыре безнаковых байта char и напрямую посмотреть, а что же там лежит.
3. `Const_cast` - Позволяет превращать const переменные в не const и на оборот.

Попробуем поиграть)?

```
#include <iostream>

int main()
{
    double a = 3.1415;
    int b = a;// неявное приписывание (int)
    int c = (int)a;// Явное приписывание (int) и преобразование к целому числу
    int d = static_cast <int> (a);// Супер явный вызов static_cast, который по факту и происходил в случаях сверху
    //int e = reinterpret_cast <int> (a);
    std::cout<< a << '\n' << b << '\n' << c << '\n' << d << '\n' << std::endl;
    return 0;
}
```

Работает и пишет одну и туже тройку. Пока скучно. Однако, если попробовать расскоментировать reinterpret_cast то всё ломается. Почему? Надеюсь вы уже побежали на cppref (на правах рекламы) смотреть, что-же написано не так. И конечно же вы поняли, что всё гениальное просто... не про этот случай. `reinterpret_cast` это преобразователь ссылок, поэтому принимает он в себя именно ссылочные типы (ну или целочисленные, но в таком случае он скорее поведёт себя, как static), переделывая их в другие, но не меняя само значение. Контрольный вопрос - что требуется исправить?.. Надеюсь, в этот раз вы достойны пирожка с полочки)

```
#include <iostream>

int main()
{
    double a = 3.1415;
    int b = a;// неявное приписывание (int)
    int c = (int)a;// Явное приписывание (int) и преобразование к целому числу
    int d = static_cast <int> (a);// Супер явный вызов static_cast, который по факту и происходил в случаях сверху
    int e = *(reinterpret_cast <int*> (&a));
    std::cout<< a << '\n' << b << '\n' << c << '\n' << d << '\n' << e << std::endl;
    return 0;
}
```

Замедьте одну тонкую вещь - е получает копию того, что хранилось по ссылке в начале double переменной. То есть если изменить значение e, то само a не изменится. Тогда вопрос, можно ли постучать во внутренности самой a? Тоже вам вопрос на подумать)

<details>
<summary>Для ленивых</summary>
    double a = 2.1415;
    a++;// антиоптимизация

    int* g = reinterpret_cast <int*> (&a);
    g[0] = 0;// изменяем элемент под g и следующий за ним, чтобы точно сломать весь double (внутри 8 байт, и все 8 обнулим)
    g[1] = 0;
    std::cout << a << std::endl;
</details>

Надеюсь осознание, чем именно занимается reinterpret к вам пришло. Если нет, стучите.

Последним моментом был `const_cast`. Тот самый, который константные переменные делает не константными. Наоборот, честно говоря, может даже static_cast справится.

```
#include <iostream>

int main()
{
    int a = 0;
    const int y = static_cast<const int> (a);
    std::cout << y << std::endl;
    return 0;
}
```

А вот с тем, чтобы убрать константность он уже не совладает (тем более при его использовании создаётся новая переменна, а вот const_cast изменяет ссылку на старую, точнее убирает наклейку const). 

```
#include <iostream>

int main()
{
    int a = 0;
    const int y = static_cast<const int> (a);
    (*const_cast <int*> (&y))++;
    std::cout << y << std::endl;
    return 0;
}
```

Можете поиграть, что же будет, если изменить изначально константную переменную. Но в целом это чуть вне рамок нашего диалога (монолога?), поэтому смотрим лекции).

## Си строки

### Кто это

Ещё один важный наследник из языка Си, про который стоит как можно быстрее забыть, но всегда стоит помнить - строковые переменные. А именно их отсуствие в данном языке. Да и правда, зачем? Есть лучше! Массив char*!

В общем да, строки в оригинальном языке обозначаются как `char[]` или `char*`. Константы в виде "Hello" аналогично являются массивами char* = {'H', 'e', 'l', 'l', 'o', '\0'} и ничем более. Хотя, с точки зрения абстрактного уровня все слова и даже тексты это просто наборы символов, так что мало вероятно (разве что в сжатом виде) вы увидите какую то иную интерпретацию текста отличную от простого посимвольного кодирования в других языках.

```
#include <iostream>
#include <stdio.h>

int main()
{
    char a[] = "Hello";// Да, размер массива он сам подсчитает. Можете тот же фокус с int[] = {1,2,3} проделать
    printf ("%s \n", a);
    std::cout << a << "2" << std::endl;
}
```

Да, думаю вы уже заметили кое какую не стыковку. Длинна массива на один символ больше, как говорят подсказки IDE, ну или просто абзац выше. А всё дело в символе `'\0'`, что по факту обозначает конец строки (или текста). И именно в нём содержится большая часть магии, которая отличает char* от обычного массива, так как позволяет выполнять над такими массивами строковые функции за счёт познания позиции конца строки.

### С чем едят

Так, надо бы испробовать всё это. Но перед этим надо где-то взять эти самые строковые функции. Что значит нехочу туда идти? Надо. Тем более только взгляните на этот набор - https://en.cppreference.com/w/c/string/byte

Тут и проверки на разные типы символов, и преобразования строк в числа, и манипуляции с самими строками, выдающие подстроки, копии или просто склеивающие их. И замедьте самые вкусняшки снизу - memset, memcmp, memcpy. Почему вкусняшки? На первом дз поймёте.

Советую ещё обратить внимание на один значительный пункт - в cppref для функций часто требуется что-то `include'ить`. А что именно написанно мааааленьким шрифтом под оглавлением страницы с функцией.

Ладно, давайте пробовать. Хотя всё и сразу точно не получится попробовать, поэтому большинство из этих функци попробуйте сами, но...

```
#include <ctype.h>
#include <iostream>

using std::cout; using std::endl;

int main()
{
    char a = '\0';
    char b = ' ';
    char c = '\n';
    char d = '\t';
    cout << "iscntrl " << iscntrl (a) << " " 
         << iscntrl (b) << " " << iscntrl (c)
         << " " << iscntrl (d) << endl;
}
```

Что интересно, реакцию разных функци на разные символы можно сразу глянуть в специальной таблице снизу, по вертикали - символы, по горизонтали - функции.

```
#include <ctype.h>
#include <iostream>

using std::cout; using std::endl;

int main()
{
    char a[] = "1239";
    int b = atoi(a);
    cout << ++b << endl;
}
```

Вопрос на засыпку - что будет выведено, если поставить b++? Засыпались? Молодцы)

Точно так же можно конвертировать и с разной базой (то есть можно прочитать и 16-ичное число!) и с сохранением позиции конца считывания в соседних функциях. Но нас больше интересуют `strcpy` и `strcat`.

```
#include <ctype.h>
#include <iostream>
#include <string.h>

using std::cout; using std::endl;

int main()
{
    char a[] = "1239";
    char b[] = "Hello";
    char c[11];

    strcpy (c, b);// Копируем в c строку из b
    strcat (c, a);// К полученной в c строке приписываем сзади a
    cout << c << endl;
}
```

Вроде простетские функции, а пользы немеренно. Кстати, хорошим упражнением будет попытаться самостоятельно написать парочку из них, чтобы понять внутренности C style string получше.

### memcmp, memset, memcpy

Чуть особняком стоят ещё такие функции, как memcmp, memset и memcpy. Фокус в том, что им можно на вход подать массив любого типа (void*) с его размером, и они сами сделают нужную работу, причём на порядок быстрее классических пробеганий по циклу. Что значит быстрее? А означает это, что функции просто побайтово сравнивают два участка памяти не заботясь об адресации и оптимизации хранения этих самых массивов в памяти. И засчёт прямого сравнения и коипрования данных целиком без "волшебных" сдвигов данные функции выигрывают в скорости. Однако стоит предостеречь от использования их в массивах классов или структур, так как там располложение данных может быть не тривиальным.

```
#include <ctype.h>
#include <iostream>
#include <string.h>

using std::cout; using std::endl;

int main()
{
    char a[12];
    a[11] = '\0';
    char c[11];
    memset (c, 'a', 11);
    memset (a, 'b', 11);
    cout << c << endl;
    memcpy (a, c, 5);
    cout << a << endl;
}
```

Кстати, если с первого раза у вас вывелось всё корректно (в начале напечатались только 'a'), то попробуйте позапускать программу ещё пару раз. В итоге хоть раз у вас будет не совсем правильный вывод. Да, это тоже вопрос на подумать что-ж случилось то)

<details>
<summary>Тыц</summary>
    Всё просто. mem функции от слова совсем не заботятся об терминальном символе '\0', из за чего после последнего символа строки `c` идёт сразу лежащая по соседству строка `a`. И cout считает, что на самом деле строка `c` заканчивается дальше, так как ближайший терминальный символ лежит в строке `a`. Получаем распечатанную сумму строк)
</details>

С остальными функциями предлагаю вам поиграть самостоятельно. Как минимум, сравнение строк вам точно пригодиться при написании дз.

## argc, argv

Последнее приключение на сегодня - ввод в функцию через аргументы консоли. Да, те самые, которые через пробле с минусом типа ls -l. Вот -l как раз и есть аргумент, передающийся через эти переменные. Так, а где мы должны взять эти переменные? Нет, они не предопределены в языке, да и зачем, когда у нас есть аргументы в main! На бис, последний заход в cppref https://en.cppreference.com/w/cpp/language/main_function

Как видим, функция main принимает 2 аргумента `int argc`, `char* argv[]`. По второму сразу отвечу что да, это массив массивов (точнее строк). Итак, первый аргумент являет собой размер второго аргумента, а по русски - количество переданных на вход параметров, разделённых терминальными символами (включая пробел, табуляцию и так далее). Второй аргумент - собственно принятые на вход сами параметры, как тот же -l. 

По идее тут должен появится пример кода, однако маленькая оговорочка - работать будем сразу и с башем и с Cи кодом.

```
#include <iostream>

using std::cout; using std::endl;

int main(int argc,char* argv[])
{
    cout << "argc = " << argc << endl;
    for (int i = 0; i < argc ; i++)
    {
        cout << argv[i] << endl;
    }
}
```

Попробуйте запустить такую программу с несколькими аргументами и посмотреть что произойдёт. Если вы выполняете код в IDE, то можно задать аргументы программе в настройках проекта (их уж ищите сами). В VS code это файл launch.json . Но в целом, крайне рекомендую перейти в консоль и запускать код от туда.

```
./a.out 123 456 abc
```

Итак, мы увидели все параметры, пришедшие на вход. И ещё один, самый первый, имя нашей программы. Довольно не ожидано, но бывает полезно, если нам требуется запустить ещё пару раз себя ~~для захвата компьютера~~ в мультипоточном сценарии, но об этом в следующих семестрах.

Итак, где лежат наши аргументы мы знаем. Теперь вопрос, что же с ними делать? И тут вы должны были уже вспомнить, что до этого мы работали со строками. В простейшем варианте вспоминаем наболевшую конструкцию switch... И понимаем, что работает она только для целых чисел либо enum (тип перечесления). Можно кончено написать свой Switch, но это потребует constexpr... короче не надо. Ладно, вспоминаем if'ы.

```
#include <ctype.h>
#include <iostream>
#include <string.h>

using std::cout; using std::endl;

int main(int argc,char* argv[])
{
    cout << "argc = " << argc << endl;
    for (int i = 0; i < argc ; i++)
    {
        if (!strcmp ("123", argv[i]))
        {
            cout << "Нашёл 123!" << endl;
            continue;
        }

        if (!strcmp ("456", argv[i]))
        {
            cout << "Нашёл 456!" << endl;
            continue;
        }

        cout << "Дичь какая то!" << endl;
    }
}
```

Код конечно не самый лучший, но уже как вариант. С точки зрения правильной работы всё сильно зависит от целей вашей программы и типов параметров. Так, флаги в идеале содержать в массиве vector\<bool\> arg_flags. И стучаться к ним по созданым заранее enum или define для увеличения читаемости. Либо, если флагов действительно разнообразных бывает не много, можно просто хранить пару переменных, хотя не рекомендуется. Для более сложных параметров по типу пути к файлу или паролю/порту лучше завести массив строк vector\<String\> str_arguments.

```
#include <ctype.h>
#include <iostream>
#include <string.h>
#include <vector>
#include <string>

#define PORT 1// Для читаемости кода

using std::cout; using std::endl; using std::vector; using std::string;

int main(int argc,char* argv[])
{
    vector <string> argv_strings (argc - 1);// Создаём массив пустых строк под каждый параметр, хотя можно и меньше, зависит от того, что может придти на вход
    cout << "argc = " << argc << endl;
    for (int i = 0; i < argc ; i++)
    {
        if (!strcmp ("123", argv[i]))
        {
            cout << "Нашёл 123!" << endl;
            continue;
        }

        if (!strcmp ("-p", argv[i]))
        {
            //cout << "Нашёл p" << endl;
            ++i;
            argv_strings [PORT] = argv[i];
            continue;
        }

        cout << "Дичь какая то!" << endl;
    }

    cout << "Порт = " << argv_strings [PORT] << endl;
}
```

Запускаем

```
./a.out 123 -p 12345
```

В требованиях к программме, чтобы лишний раз не прыгать по аргументам, вы можете прописать, что формат аргументов должен быть через =. По типу p=12345. Тогда сравнение `strcmp` потребуется заменить на `strncmp`, где можно ввести сколько символов сравнивать - `strncmp ("-p=", argv[i], 3)`, а после, начиная с позиции 3 уже считать сам порт. А? Что такое порт? Нууу, потом как нибудь)

Если ваши аргументы делают что-то ещё более сложное, то тут уже требуется думать по ситуации. Вполне возможно, что вам придётся писать целые функции для каждого аргумента. Или массивы функций. В целом, можете продумывать архитектуру на ваше усмотрение. Для задач парсинга даже были созданы некоторые библиотеки, но с их API требуется внимательно разбираться, и думаю это тоже выходит за рамки... ну ладно, вот один примерчик, который даже читать не хочу https://www.gnu.org/software/libc/manual/html_node/Argp-Example-3.html .

Самым последним пунктом в догонку хотел сказать, что у main есть ещё и return метод, возвращающий какие то значения. Вопрос, а кто их принимает то? Ответ - родительский процесс или программа, запустившая данную. В случае с консолью return из программы принимает bash, у которого можно даже попросить сохранить это значение

```
#include <stdio.h>
  
int main()
{
    int a = 1;
    a++;
    return a;
}
```
bash:
```
./a.out
$A=$?
echo $A
```

В целом, на этом всё на этот семинар. Надеюсь, хоть на каплю эксперимент удался)